<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300&display=swap">
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>

  <body>
    <h1>Projet DataViz</h1>
    <h3>Let's face reality and compare yourself to the very best to witness how bad you are at running</h2>

    <div class="selector-container">
      <label for="genderSelector">Select Gender:</label>
      <select id="genderSelector">
        <option value="Men">Men</option>
        <option value="Women">Women</option>
      </select>
    </div>

    <div class="selector-container">
      <label for="distanceSelector">Distance:</label>
      <select id="distanceSelector">
        <option value="100">100m</option>
        <option value="200">200m</option>
        <option value="400">400m</option>
        <option value="800">800m</option>
        <option value="1500">1500m</option>
        <option value="5000">5000m</option>
        <option value="10000">10000m</option>
        <option value="21098">Half Marathon (21km)</option>
        <option value="42195">Marathon (42km)</option>
      </select>
    </div>

    <div class="selector-container">
      <label for="topSelector">Rank:</label>
      <select id="topSelector">
        <option value="1">Top 1</option>
        <option value="10">Top 10</option>
        <option value="100">Top 100</option>
        <option value="1000">Top 1000</option>
      </select>
    </div>

    <div class="selector-container">
      <label for="performanceSelector">Your performance:</label>
      <select id="performanceSelector">
        <option value="1">Bad runner</option>
        <option value="2">Average runner</option>
        <option value="3">Good runner</option>
        <option value="4">Excellent runner</option>
      </select>
    </div>

    <div id="result"></div>
    <div id="raceContainer2"></div>
    <div id="raceContainer"></div>
    <hr style="margin-top: 20px; margin-bottom: 20px;">
    <h3 style="text-align: center;">Evolution of 
      <span id="txtGender" style="font-weight: bold;"></span> 
      <span id="txtDistance" style="font-weight: bold;"></span> 
      over time
    </h2>
    <div id="scatterplot"></div> 

    <script>
      // Load des données
      Promise.all([
        d3.csv("data.csv"),
        d3.csv("normalPerformances.csv")
      ]).then(function ([data, normalPerformances]) {

        // Filtrage sur les selectors
        function filterData(gender, distance, top, performance) {
          const filteredData = data.filter(
            (d) => d.Gender === gender &&
              parseInt(d.Distance) === parseInt(distance)
          );
          
          // Filtrage sur la sélection de top
          switch (top) {
            case 1:
              return filteredData.slice(0, 1);
            case 10:
              return filteredData.slice(9, 10);
            case 100:
              return filteredData.slice(99, 100);
            case 1000:
              return [filteredData[filteredData.length - 1]];
            default:
              return [];
          }
        }

        function updateResult() {
          // Données des différents selectors
          const selectedGender = document.getElementById("genderSelector").value;
          const selectedDistance = document.getElementById("distanceSelector").value;
          const selectedTop = parseInt(document.getElementById("topSelector").value);
          const selectedPerformance = parseInt(document.getElementById("performanceSelector").value);
          const filteredData = filterData(selectedGender, selectedDistance, selectedTop, selectedPerformance);

          // Message "Your performance vs X"
          const resultDiv = d3.select("#result");
          // Suppression de l'élément à chaque mise à jour pour éviter de dupliquer à l'infini
          resultDiv.selectAll("*").remove();
          const resultList = resultDiv.append("ul");
          const listItems = resultList
            .selectAll("li")
            .data(filteredData)
            .enter()
            .append("li")
            .html((d) => `Your performance (red track)<br><strong>VS</strong><br>${d.Name} - ${d.TimeInS}s - ${d.AvgSpeed}m/s [${d.Date}]`)
            .style("text-align", "center");

          // Recherche dans le 2eme csv des performances Bad/Average/Good/Excellent runner
          const normalPerformance = normalPerformances.find(
            (d) => d.Gender === selectedGender &&
              parseInt(d.Distance) === parseInt(selectedDistance) &&
              parseInt(d.Performance) === selectedPerformance
          );

          // Ici on s'occupe des 2 tracks
          if (normalPerformance) {
            // Valeurs de délai pour ralentir l'animation de course
            const delayValue = 30000
            const normalDisplaySpeed = delayValue / parseFloat(normalPerformance.AvgSpeed);
            const displaySpeed = delayValue / parseFloat(filteredData[0].AvgSpeed);
            // Taille des tracks
            const svgWidth = window.innerWidth - 100;
            const svgHeight = 30;
            const trackRacePadding = 70;

            // Suppression des éléments à chaque mise à jour pour éviter de dupliquer à l'infini
            d3.select("#raceContainer").selectAll("svg").remove();
            d3.select("#raceContainer2").selectAll("svg").remove();

            // Track 1 et 2
            const svg = d3.select("#raceContainer")
              .append("svg")
              .attr("width", svgWidth)
              .attr("height", svgHeight);
            const svg2 = d3.select("#raceContainer2")
              .append("svg")
              .attr("width", svgWidth)
              .attr("height", svgHeight);
            svg.append("line")
              .attr("x1", trackRacePadding)
              .attr("y1", svgHeight / 2)
              .attr("x2", svgWidth - trackRacePadding)
              .attr("y2", svgHeight / 2)
              .attr("stroke", "#000")
              .attr("stroke-width", 3);
            svg2.append("line")
              .attr("x1", trackRacePadding)
              .attr("y1", svgHeight / 2)
              .attr("x2", svgWidth - trackRacePadding)
              .attr("y2", svgHeight / 2)
              .attr("stroke", "red")
              .attr("stroke-width", 3);

            // Icones 1 et 2
            const runningIcon = svg.append("image")
              .attr("xlink:href", "run.png")
              .attr("width", svgHeight + 5)
              .attr("height", svgHeight + 5)
              .attr("x", trackRacePadding);
            const runningIcon2 = svg2.append("image")
              .attr("xlink:href", "run2.png")
              .attr("width", svgHeight + 5)
              .attr("height", svgHeight + 5)
              .attr("x", trackRacePadding);
            runningIcon.transition()
              .duration(displaySpeed)
              .attr("x", svgWidth - trackRacePadding);
            runningIcon2.transition()
              .duration(normalDisplaySpeed)
              .attr("x", svgWidth - trackRacePadding);
          }
          createScatterplot(selectedGender, selectedDistance);
        }


        function createScatterplot(selectedGender, selectedDistance) {
          const filteredData = data.filter(
            (d) => d.Gender === selectedGender &&
              parseInt(d.Distance) === parseInt(selectedDistance)
          );

          // Récupération des données pour le title
          const selectedDistanceOption = document.getElementById("distanceSelector");
          d3.select("#txtGender").text(selectedGender);
          d3.select("#txtDistance").text(selectedDistanceOption.options[selectedDistanceOption.selectedIndex].text);
          
          // On récupère les données par mois
          const nestedData = d3.group(filteredData, d => d3.timeFormat("%Y-%m")(new Date(d.Date)));
          // Et on récupère le meilleur temps par mois
          const bestTimesData = Array.from(nestedData, ([key, values]) => {
            const bestTime = d3.min(values, d => parseFloat(d.TimeInS));
            const bestTimeEntry = values.find(d => parseFloat(d.TimeInS) === bestTime);
            return {
              Date: key,
              BestTimeInS: bestTime,
              BestTimeEntry: bestTimeEntry,
            };
          });
        
          const scatterplotDiv = d3.select("#scatterplot");
          // Suppression de l'élément à chaque mise à jour pour éviter de dupliquer à l'infini
          scatterplotDiv.selectAll("svg").remove();
          // Tailles du scatterplot
          const margin = { top: 40, right: 20, bottom: 60, left: 60 }; 
          const width = 800 - margin.left - margin.right; 
          const height = 500 - margin.top - margin.bottom; 

          // Scaling
          const xScale = d3.scaleTime()
            .domain(d3.extent(bestTimesData, d => new Date(d.Date)))
            .range([0, width]);
          const yScale = d3.scaleLinear()
            .domain([d3.min(bestTimesData, d => d.BestTimeInS), d3.max(bestTimesData, d => d.BestTimeInS)])
            .range([height, 0]);
          const xAxis = d3.axisBottom(xScale);
          const yAxis = d3.axisLeft(yScale);
          const svg = scatterplotDiv.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
          
          // Tooltip
          const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
          // Sur les cercles
          svg.selectAll("circle")
            .data(bestTimesData)
            .enter().append("circle")
            .attr("cx", d => xScale(new Date(d.Date)))
            .attr("cy", d => yScale(d.BestTimeInS))
            .attr("r", 5)
            .attr("fill", "blue")
            .on("mouseover", function (event, d) {
              tooltip.transition()
                .duration(150)
                .style("opacity", .9)
                .style("left", (event.pageX + 10) + "px")  
                .style("top", (event.pageY - 18) + "px"); 
        
              tooltip.html(`${d.BestTimeEntry.Name}<br>${d.BestTimeEntry.TimeInS}s - ${d.BestTimeEntry.AvgSpeed}m/s [${d.BestTimeEntry.Date}]`);
            })
            .on("mouseout", function (d) {
              tooltip.transition()
                .duration(350)
                .style("opacity", 0);
          });

          svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);
          svg.append("g")
            .call(yAxis);

          // Labels sur les axes
          svg.append("text")
            .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.top) + ")") 
            .style("text-anchor", "middle")
            .text("Date");
          svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("x", 0 - (height / 2))
            .style("text-anchor", "middle")
            .text("Time (s)")
            .attr("y", -40);
        }
        
        // Initial update
        updateResult();

        // Event listeners
        d3.select("#genderSelector").on("change", updateResult);
        d3.select("#distanceSelector").on("change", updateResult);
        d3.select("#topSelector").on("change", updateResult);
        d3.select("#performanceSelector").on("change", updateResult);
      });
    </script>
  </body>
</html>
